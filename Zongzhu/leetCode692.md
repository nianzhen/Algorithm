
# 给一非空的单词列表，返回前 k 个出现次数最多的单词。

 返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序。

    示例 1：

    输入: ["i", "love", "leetcode", "i", "love", "coding"], k = 2
    输出: ["i", "love"]
    解析: "i" 和 "love" 为出现次数最多的两个单词，均为2次。
        注意，按字母顺序 "i" 在 "love" 之前。
    示例 2：

    输入: ["the", "day", "is", "sunny", "the", "the", "the", "sunny", "is", "is"], k = 4
    输出: ["the", "is", "sunny", "day"]
    解析: "the", "is", "sunny" 和 "day" 是出现次数最多的四个单词，
        出现次数依次为 4, 3, 2 和 1 次。

    注意：

    假定 k 总为有效值， 1 ≤ k ≤ 集合元素数。
    输入的单词均由小写字母组成。


题目分析：

1. 去重，频率 ===> hash表最合适
2. 排序（优先级队列） ===> 堆

经典的前 Top K 场景问题

1. 遍历该数组，当遍历到该数组单词时，先去散列表中进行查询，如果查到了，记录次数+1。否则插入散列表中。遍历结束后，散列表中存储了不重复的单词，以及出现的次数频率。时间复杂度为O(n)。空间复杂度O(n)。

2.  快速排序得到结果。时间复杂度为O(nlogn)
3. （最优解）建立一个大小为k的小顶堆。便利该散列表，依次取出每个搜索关键词以及对应的次数，然后与堆顶的单词比较（最小），如果大于，则删除堆顶元素，将当前关键词加入堆中，重新排序。如果小于则忽略掉。依次类推，遍历完成之后，堆中就是出现次数最多的单词。

